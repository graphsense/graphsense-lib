# coding: utf-8

"""
    GraphSense API

    GraphSense API provides programmatic access to various ledgers' addresses, entities, blocks, transactions and tags for automated and highly efficient forensics tasks.  # noqa: E501

    Contact: contact@ikna.io
    Generated by: https://openapi-generator.tech
"""

import warnings
from pydantic import Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from graphsense.models.address import Address
from graphsense.models.address_tags import AddressTags
from graphsense.models.address_txs import AddressTxs
from graphsense.models.entity import Entity
from graphsense.models.links import Links
from graphsense.models.neighbor_addresses import NeighborAddresses
from graphsense.models.related_addresses import RelatedAddresses
from graphsense.models.tag_summary import TagSummary

from graphsense.api_client import ApiClient, RequestSerialized
from graphsense.compat import Height
from graphsense.api_response import ApiResponse
from graphsense.rest import RESTResponseType

# Backward compatibility wrapper for @validate_call to accept async_req
from functools import wraps
from datetime import datetime as _dt_compat
from pydantic import ConfigDict
_validate_call_config = ConfigDict(arbitrary_types_allowed=True)


class _AsyncResult:
    """v5-compatible async result wrapper around concurrent.futures.Future."""
    def __init__(self, future):
        self._future = future

    def get(self, timeout=None):
        """Block and return the result, like v5's ApplyResult.get()."""
        return self._future.result(timeout=timeout)

    def ready(self):
        """Check if the result is ready."""
        return self._future.done()

    def successful(self):
        """Check if the call completed without exception."""
        if not self._future.done():
            return False
        return self._future.exception() is None


def validate_call_compat(func):
    """Wrapper that filters out legacy kwargs like async_req before validation."""
    from pydantic import validate_call as _validate_call
    # Apply validate_call with config that allows arbitrary types
    validated_func = _validate_call(config=_validate_call_config)(func)
    @wraps(func)
    def wrapper(*args, **kwargs):
        # Capture async_req before removing it
        async_req = kwargs.pop('async_req', False)
        kwargs.pop('_preload_content', None)
        kwargs.pop('_return_http_data_only', None)
        # Convert datetime to date string for date parameters (backward compatibility)
        # Preserve full ISO 8601 format when datetime has time/timezone info
        for key in list(kwargs.keys()):
            if 'date' in key.lower() and isinstance(kwargs[key], _dt_compat):
                dt = kwargs[key]
                if dt.hour or dt.minute or dt.second or dt.tzinfo:
                    # Preserve full datetime with timezone (ISO 8601)
                    kwargs[key] = dt.isoformat()
                else:
                    # Date-only (midnight, no timezone) - use simple format
                    kwargs[key] = dt.strftime('%Y-%m-%d')
        # Also check positional args - var_date is typically arg[1]
        args = list(args)
        for i, arg in enumerate(args):
            if isinstance(arg, _dt_compat):
                if arg.hour or arg.minute or arg.second or arg.tzinfo:
                    args[i] = arg.isoformat()
                else:
                    args[i] = arg.strftime('%Y-%m-%d')

        # Handle async_req: submit to thread pool if available
        if async_req:
            # args[0] is self (the API instance), which has api_client
            api_instance = args[0]
            if hasattr(api_instance, 'api_client'):
                thread_pool = getattr(api_instance.api_client, '_thread_pool', None)
                if thread_pool is not None:
                    future = thread_pool.submit(validated_func, *args, **kwargs)
                    return _AsyncResult(future)
                else:
                    import warnings
                    warnings.warn(
                        "async_req=True but no thread pool available (pool_threads=0). "
                        "Running synchronously. Set pool_threads >= 1 for async execution.",
                        UserWarning
                    )
            # No thread pool available, fall through to sync call

        return validated_func(*args, **kwargs)
    return wrapper


class AddressesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call_compat
    def get_address(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Address:
        """Get an address

        Get an address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_address_serialize(
            currency=currency,
            address=address,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Address",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def get_address_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Address]:
        """Get an address

        Get an address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_address_serialize(
            currency=currency,
            address=address,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Address",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def get_address_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an address

        Get an address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_address_serialize(
            currency=currency,
            address=address,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Address",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_address_serialize(
        self,
        currency,
        address,
        include_actors,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if address is not None:
            _path_params['address'] = address
        # process the query parameters
        if include_actors is not None:
            
            _query_params.append(('include_actors', include_actors))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/addresses/{address}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def get_address_entity(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Entity:
        """Get the entity of an address

        Get the entity of an address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_address_entity_serialize(
            currency=currency,
            address=address,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Entity",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def get_address_entity_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Entity]:
        """Get the entity of an address

        Get the entity of an address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_address_entity_serialize(
            currency=currency,
            address=address,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Entity",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def get_address_entity_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the entity of an address

        Get the entity of an address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_address_entity_serialize(
            currency=currency,
            address=address,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Entity",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_address_entity_serialize(
        self,
        currency,
        address,
        include_actors,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if address is not None:
            _path_params['address'] = address
        # process the query parameters
        if include_actors is not None:
            
            _query_params.append(('include_actors', include_actors))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/addresses/{address}/entity',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def get_tag_summary_by_address(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        include_best_cluster_tag: Annotated[Optional[StrictBool], Field(description="If the best cluster tag should be inherited to the address level")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TagSummary:
        """Get attribution tag summary for a given address

        Get attribution tag summary for a given address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param include_best_cluster_tag: If the best cluster tag should be inherited to the address level
        :type include_best_cluster_tag: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tag_summary_by_address_serialize(
            currency=currency,
            address=address,
            include_best_cluster_tag=include_best_cluster_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TagSummary",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def get_tag_summary_by_address_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        include_best_cluster_tag: Annotated[Optional[StrictBool], Field(description="If the best cluster tag should be inherited to the address level")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TagSummary]:
        """Get attribution tag summary for a given address

        Get attribution tag summary for a given address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param include_best_cluster_tag: If the best cluster tag should be inherited to the address level
        :type include_best_cluster_tag: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tag_summary_by_address_serialize(
            currency=currency,
            address=address,
            include_best_cluster_tag=include_best_cluster_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TagSummary",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def get_tag_summary_by_address_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        include_best_cluster_tag: Annotated[Optional[StrictBool], Field(description="If the best cluster tag should be inherited to the address level")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get attribution tag summary for a given address

        Get attribution tag summary for a given address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param include_best_cluster_tag: If the best cluster tag should be inherited to the address level
        :type include_best_cluster_tag: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tag_summary_by_address_serialize(
            currency=currency,
            address=address,
            include_best_cluster_tag=include_best_cluster_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TagSummary",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tag_summary_by_address_serialize(
        self,
        currency,
        address,
        include_best_cluster_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if address is not None:
            _path_params['address'] = address
        # process the query parameters
        if include_best_cluster_tag is not None:
            
            _query_params.append(('include_best_cluster_tag', include_best_cluster_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/addresses/{address}/tag_summary',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_address_links(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        neighbor: Annotated[StrictStr, Field(description="Neighbor address")],
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Links:
        """Get outgoing transactions between two addresses

        Get outgoing transactions between two addresses

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param neighbor: Neighbor address (required)
        :type neighbor: str
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_address_links_serialize(
            currency=currency,
            address=address,
            neighbor=neighbor,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Links",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_address_links_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        neighbor: Annotated[StrictStr, Field(description="Neighbor address")],
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Links]:
        """Get outgoing transactions between two addresses

        Get outgoing transactions between two addresses

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param neighbor: Neighbor address (required)
        :type neighbor: str
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_address_links_serialize(
            currency=currency,
            address=address,
            neighbor=neighbor,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Links",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_address_links_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        neighbor: Annotated[StrictStr, Field(description="Neighbor address")],
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get outgoing transactions between two addresses

        Get outgoing transactions between two addresses

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param neighbor: Neighbor address (required)
        :type neighbor: str
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_address_links_serialize(
            currency=currency,
            address=address,
            neighbor=neighbor,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Links",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_address_links_serialize(
        self,
        currency,
        address,
        neighbor,
        min_height,
        max_height,
        min_date,
        max_date,
        order,
        token_currency,
        page,
        pagesize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if address is not None:
            _path_params['address'] = address
        # process the query parameters
        if neighbor is not None:
            
            _query_params.append(('neighbor', neighbor))
            
        if min_height is not None:
            
            _query_params.append(('min_height', min_height))
            
        if max_height is not None:
            
            _query_params.append(('max_height', max_height))
            
        if min_date is not None:
            
            _query_params.append(('min_date', min_date))
            
        if max_date is not None:
            
            _query_params.append(('max_date', max_date))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if token_currency is not None:
            
            _query_params.append(('token_currency', token_currency))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/addresses/{address}/links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_address_neighbors(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        direction: Annotated[StrictStr, Field(description="Incoming or outgoing neighbors")],
        only_ids: Annotated[Optional[StrictStr], Field(description="Restrict result to given set of comma separated addresses")] = None,
        include_labels: Annotated[Optional[StrictBool], Field(description="Whether to include labels of first page of address tags")] = None,
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NeighborAddresses:
        """Get an address's neighbors in the address graph

        Get an address's neighbors in the address graph

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param direction: Incoming or outgoing neighbors (required)
        :type direction: str
        :param only_ids: Restrict result to given set of comma separated addresses
        :type only_ids: str
        :param include_labels: Whether to include labels of first page of address tags
        :type include_labels: bool
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_address_neighbors_serialize(
            currency=currency,
            address=address,
            direction=direction,
            only_ids=only_ids,
            include_labels=include_labels,
            include_actors=include_actors,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NeighborAddresses",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_address_neighbors_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        direction: Annotated[StrictStr, Field(description="Incoming or outgoing neighbors")],
        only_ids: Annotated[Optional[StrictStr], Field(description="Restrict result to given set of comma separated addresses")] = None,
        include_labels: Annotated[Optional[StrictBool], Field(description="Whether to include labels of first page of address tags")] = None,
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NeighborAddresses]:
        """Get an address's neighbors in the address graph

        Get an address's neighbors in the address graph

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param direction: Incoming or outgoing neighbors (required)
        :type direction: str
        :param only_ids: Restrict result to given set of comma separated addresses
        :type only_ids: str
        :param include_labels: Whether to include labels of first page of address tags
        :type include_labels: bool
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_address_neighbors_serialize(
            currency=currency,
            address=address,
            direction=direction,
            only_ids=only_ids,
            include_labels=include_labels,
            include_actors=include_actors,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NeighborAddresses",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_address_neighbors_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        direction: Annotated[StrictStr, Field(description="Incoming or outgoing neighbors")],
        only_ids: Annotated[Optional[StrictStr], Field(description="Restrict result to given set of comma separated addresses")] = None,
        include_labels: Annotated[Optional[StrictBool], Field(description="Whether to include labels of first page of address tags")] = None,
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an address's neighbors in the address graph

        Get an address's neighbors in the address graph

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param direction: Incoming or outgoing neighbors (required)
        :type direction: str
        :param only_ids: Restrict result to given set of comma separated addresses
        :type only_ids: str
        :param include_labels: Whether to include labels of first page of address tags
        :type include_labels: bool
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_address_neighbors_serialize(
            currency=currency,
            address=address,
            direction=direction,
            only_ids=only_ids,
            include_labels=include_labels,
            include_actors=include_actors,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NeighborAddresses",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_address_neighbors_serialize(
        self,
        currency,
        address,
        direction,
        only_ids,
        include_labels,
        include_actors,
        page,
        pagesize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if address is not None:
            _path_params['address'] = address
        # process the query parameters
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        if only_ids is not None:
            
            _query_params.append(('only_ids', only_ids))
            
        if include_labels is not None:
            
            _query_params.append(('include_labels', include_labels))
            
        if include_actors is not None:
            
            _query_params.append(('include_actors', include_actors))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/addresses/{address}/neighbors',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_address_txs(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        direction: Annotated[Optional[StrictStr], Field(description="Incoming or outgoing transactions")] = None,
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AddressTxs:
        """Get all transactions an address has been involved in

        Get all transactions an address has been involved in

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param direction: Incoming or outgoing transactions
        :type direction: str
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_address_txs_serialize(
            currency=currency,
            address=address,
            direction=direction,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTxs",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_address_txs_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        direction: Annotated[Optional[StrictStr], Field(description="Incoming or outgoing transactions")] = None,
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AddressTxs]:
        """Get all transactions an address has been involved in

        Get all transactions an address has been involved in

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param direction: Incoming or outgoing transactions
        :type direction: str
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_address_txs_serialize(
            currency=currency,
            address=address,
            direction=direction,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTxs",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_address_txs_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        direction: Annotated[Optional[StrictStr], Field(description="Incoming or outgoing transactions")] = None,
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all transactions an address has been involved in

        Get all transactions an address has been involved in

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param direction: Incoming or outgoing transactions
        :type direction: str
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_address_txs_serialize(
            currency=currency,
            address=address,
            direction=direction,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTxs",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_address_txs_serialize(
        self,
        currency,
        address,
        direction,
        min_height,
        max_height,
        min_date,
        max_date,
        order,
        token_currency,
        page,
        pagesize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if address is not None:
            _path_params['address'] = address
        # process the query parameters
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        if min_height is not None:
            
            _query_params.append(('min_height', min_height))
            
        if max_height is not None:
            
            _query_params.append(('max_height', max_height))
            
        if min_date is not None:
            
            _query_params.append(('min_date', min_date))
            
        if max_date is not None:
            
            _query_params.append(('max_date', max_date))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if token_currency is not None:
            
            _query_params.append(('token_currency', token_currency))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/addresses/{address}/txs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_related_addresses(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        address_relation_type: Annotated[Optional[StrictStr], Field(description="What type of related addresses to return")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RelatedAddresses:
        """Get related addresses to the input address

        Get related addresses to the input address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param address_relation_type: What type of related addresses to return
        :type address_relation_type: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_related_addresses_serialize(
            currency=currency,
            address=address,
            address_relation_type=address_relation_type,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RelatedAddresses",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_related_addresses_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        address_relation_type: Annotated[Optional[StrictStr], Field(description="What type of related addresses to return")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RelatedAddresses]:
        """Get related addresses to the input address

        Get related addresses to the input address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param address_relation_type: What type of related addresses to return
        :type address_relation_type: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_related_addresses_serialize(
            currency=currency,
            address=address,
            address_relation_type=address_relation_type,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RelatedAddresses",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_related_addresses_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        address_relation_type: Annotated[Optional[StrictStr], Field(description="What type of related addresses to return")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get related addresses to the input address

        Get related addresses to the input address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param address_relation_type: What type of related addresses to return
        :type address_relation_type: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_related_addresses_serialize(
            currency=currency,
            address=address,
            address_relation_type=address_relation_type,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RelatedAddresses",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_related_addresses_serialize(
        self,
        currency,
        address,
        address_relation_type,
        page,
        pagesize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if address is not None:
            _path_params['address'] = address
        # process the query parameters
        if address_relation_type is not None:
            
            _query_params.append(('address_relation_type', address_relation_type))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/addresses/{address}/related_addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_tags_by_address(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        include_best_cluster_tag: Annotated[Optional[StrictBool], Field(description="If the best cluster tag should be inherited to the address level")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AddressTags:
        """Get attribution tags for a given address

        Get attribution tags for a given address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param include_best_cluster_tag: If the best cluster tag should be inherited to the address level
        :type include_best_cluster_tag: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tags_by_address_serialize(
            currency=currency,
            address=address,
            page=page,
            pagesize=pagesize,
            include_best_cluster_tag=include_best_cluster_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTags",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_tags_by_address_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        include_best_cluster_tag: Annotated[Optional[StrictBool], Field(description="If the best cluster tag should be inherited to the address level")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AddressTags]:
        """Get attribution tags for a given address

        Get attribution tags for a given address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param include_best_cluster_tag: If the best cluster tag should be inherited to the address level
        :type include_best_cluster_tag: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tags_by_address_serialize(
            currency=currency,
            address=address,
            page=page,
            pagesize=pagesize,
            include_best_cluster_tag=include_best_cluster_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTags",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_tags_by_address_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        address: Annotated[StrictStr, Field(description="The cryptocurrency address")],
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        include_best_cluster_tag: Annotated[Optional[StrictBool], Field(description="If the best cluster tag should be inherited to the address level")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get attribution tags for a given address

        Get attribution tags for a given address

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param address: The cryptocurrency address (required)
        :type address: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param include_best_cluster_tag: If the best cluster tag should be inherited to the address level
        :type include_best_cluster_tag: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tags_by_address_serialize(
            currency=currency,
            address=address,
            page=page,
            pagesize=pagesize,
            include_best_cluster_tag=include_best_cluster_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTags",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_tags_by_address_serialize(
        self,
        currency,
        address,
        page,
        pagesize,
        include_best_cluster_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if address is not None:
            _path_params['address'] = address
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        if include_best_cluster_tag is not None:
            
            _query_params.append(('include_best_cluster_tag', include_best_cluster_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/addresses/{address}/tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


