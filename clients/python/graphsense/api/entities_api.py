# coding: utf-8

"""
    GraphSense API

    GraphSense API provides programmatic access to various ledgers' addresses, entities, blocks, transactions and tags for automated and highly efficient forensics tasks.  # noqa: E501

    Contact: contact@iknaio.com
    Generated by: https://openapi-generator.tech
"""

import warnings
from pydantic import Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from graphsense.models.address_tags import AddressTags
from graphsense.models.address_txs import AddressTxs
from graphsense.models.entity import Entity
from graphsense.models.entity_addresses import EntityAddresses
from graphsense.models.links import Links
from graphsense.models.neighbor_entities import NeighborEntities
from graphsense.models.search_result_level1 import SearchResultLevel1

from graphsense.api_client import ApiClient, RequestSerialized
from graphsense.api_response import ApiResponse
from graphsense.rest import RESTResponseType

# Backward compatibility wrapper for @validate_call to accept async_req
from functools import wraps
from datetime import datetime as _dt_compat
from pydantic import ConfigDict
_validate_call_config = ConfigDict(arbitrary_types_allowed=True)


class _AsyncResult:
    """v5-compatible async result wrapper around concurrent.futures.Future."""
    def __init__(self, future):
        self._future = future

    def get(self, timeout=None):
        """Block and return the result, like v5's ApplyResult.get()."""
        return self._future.result(timeout=timeout)

    def ready(self):
        """Check if the result is ready."""
        return self._future.done()

    def successful(self):
        """Check if the call completed without exception."""
        if not self._future.done():
            return False
        return self._future.exception() is None


def validate_call_compat(func):
    """Wrapper that filters out legacy kwargs like async_req before validation."""
    from pydantic import validate_call as _validate_call
    # Apply validate_call with config that allows arbitrary types
    validated_func = _validate_call(config=_validate_call_config)(func)
    @wraps(func)
    def wrapper(*args, **kwargs):
        # Capture async_req before removing it
        async_req = kwargs.pop('async_req', False)
        kwargs.pop('_preload_content', None)
        kwargs.pop('_return_http_data_only', None)
        # Convert datetime to date string for date parameters (backward compatibility)
        # Preserve full ISO 8601 format when datetime has time/timezone info
        for key in list(kwargs.keys()):
            if 'date' in key.lower() and isinstance(kwargs[key], _dt_compat):
                dt = kwargs[key]
                if dt.hour or dt.minute or dt.second or dt.tzinfo:
                    # Preserve full datetime with timezone (ISO 8601)
                    kwargs[key] = dt.isoformat()
                else:
                    # Date-only (midnight, no timezone) - use simple format
                    kwargs[key] = dt.strftime('%Y-%m-%d')
        # Also check positional args - var_date is typically arg[1]
        args = list(args)
        for i, arg in enumerate(args):
            if isinstance(arg, _dt_compat):
                if arg.hour or arg.minute or arg.second or arg.tzinfo:
                    args[i] = arg.isoformat()
                else:
                    args[i] = arg.strftime('%Y-%m-%d')

        # Handle async_req: submit to thread pool if available
        if async_req:
            # args[0] is self (the API instance), which has api_client
            api_instance = args[0]
            if hasattr(api_instance, 'api_client'):
                thread_pool = getattr(api_instance.api_client, '_thread_pool', None)
                if thread_pool is not None:
                    future = thread_pool.submit(validated_func, *args, **kwargs)
                    return _AsyncResult(future)
                else:
                    import warnings
                    warnings.warn(
                        "async_req=True but no thread pool available (pool_threads=0). "
                        "Running synchronously. Set pool_threads >= 1 for async execution.",
                        UserWarning
                    )
            # No thread pool available, fall through to sync call

        return validated_func(*args, **kwargs)
    return wrapper


class EntitiesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call_compat
    def get_entity(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        exclude_best_address_tag: Annotated[Optional[StrictBool], Field(description="Whether to exclude best address tag")] = None,
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Entity:
        """Get an entity

        Get an entity

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param exclude_best_address_tag: Whether to exclude best address tag
        :type exclude_best_address_tag: bool
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_entity_serialize(
            currency=currency,
            entity=entity,
            exclude_best_address_tag=exclude_best_address_tag,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Entity",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def get_entity_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        exclude_best_address_tag: Annotated[Optional[StrictBool], Field(description="Whether to exclude best address tag")] = None,
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Entity]:
        """Get an entity

        Get an entity

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param exclude_best_address_tag: Whether to exclude best address tag
        :type exclude_best_address_tag: bool
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_entity_serialize(
            currency=currency,
            entity=entity,
            exclude_best_address_tag=exclude_best_address_tag,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Entity",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def get_entity_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        exclude_best_address_tag: Annotated[Optional[StrictBool], Field(description="Whether to exclude best address tag")] = None,
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an entity

        Get an entity

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param exclude_best_address_tag: Whether to exclude best address tag
        :type exclude_best_address_tag: bool
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_entity_serialize(
            currency=currency,
            entity=entity,
            exclude_best_address_tag=exclude_best_address_tag,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Entity",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_entity_serialize(
        self,
        currency,
        entity,
        exclude_best_address_tag,
        include_actors,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if entity is not None:
            _path_params['entity'] = entity
        # process the query parameters
        if exclude_best_address_tag is not None:
            
            _query_params.append(('exclude_best_address_tag', exclude_best_address_tag))
            
        if include_actors is not None:
            
            _query_params.append(('include_actors', include_actors))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/entities/{entity}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_address_tags_by_entity(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AddressTags:
        """(Deprecated) Get address tags for a given entity

        Get address tags for a given entity

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/tags is deprecated.", DeprecationWarning)

        _param = self._list_address_tags_by_entity_serialize(
            currency=currency,
            entity=entity,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTags",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_address_tags_by_entity_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AddressTags]:
        """(Deprecated) Get address tags for a given entity

        Get address tags for a given entity

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/tags is deprecated.", DeprecationWarning)

        _param = self._list_address_tags_by_entity_serialize(
            currency=currency,
            entity=entity,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTags",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_address_tags_by_entity_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get address tags for a given entity

        Get address tags for a given entity

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/tags is deprecated.", DeprecationWarning)

        _param = self._list_address_tags_by_entity_serialize(
            currency=currency,
            entity=entity,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTags",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_address_tags_by_entity_serialize(
        self,
        currency,
        entity,
        page,
        pagesize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if entity is not None:
            _path_params['entity'] = entity
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/entities/{entity}/tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_entity_addresses(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EntityAddresses:
        """Get an entity's addresses

        Get an entity's addresses

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_entity_addresses_serialize(
            currency=currency,
            entity=entity,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityAddresses",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_entity_addresses_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EntityAddresses]:
        """Get an entity's addresses

        Get an entity's addresses

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_entity_addresses_serialize(
            currency=currency,
            entity=entity,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityAddresses",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_entity_addresses_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an entity's addresses

        Get an entity's addresses

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_entity_addresses_serialize(
            currency=currency,
            entity=entity,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EntityAddresses",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_entity_addresses_serialize(
        self,
        currency,
        entity,
        page,
        pagesize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if entity is not None:
            _path_params['entity'] = entity
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/entities/{entity}/addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_entity_links(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        neighbor: Annotated[StrictInt, Field(description="Neighbor entity ID")],
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Links:
        """(Deprecated) Get transactions between two entities

        Get transactions between two entities

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param neighbor: Neighbor entity ID (required)
        :type neighbor: int
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/links is deprecated.", DeprecationWarning)

        _param = self._list_entity_links_serialize(
            currency=currency,
            entity=entity,
            neighbor=neighbor,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Links",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_entity_links_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        neighbor: Annotated[StrictInt, Field(description="Neighbor entity ID")],
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Links]:
        """(Deprecated) Get transactions between two entities

        Get transactions between two entities

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param neighbor: Neighbor entity ID (required)
        :type neighbor: int
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/links is deprecated.", DeprecationWarning)

        _param = self._list_entity_links_serialize(
            currency=currency,
            entity=entity,
            neighbor=neighbor,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Links",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_entity_links_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        neighbor: Annotated[StrictInt, Field(description="Neighbor entity ID")],
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get transactions between two entities

        Get transactions between two entities

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param neighbor: Neighbor entity ID (required)
        :type neighbor: int
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/links is deprecated.", DeprecationWarning)

        _param = self._list_entity_links_serialize(
            currency=currency,
            entity=entity,
            neighbor=neighbor,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Links",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_entity_links_serialize(
        self,
        currency,
        entity,
        neighbor,
        min_height,
        max_height,
        min_date,
        max_date,
        order,
        token_currency,
        page,
        pagesize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if entity is not None:
            _path_params['entity'] = entity
        # process the query parameters
        if neighbor is not None:
            
            _query_params.append(('neighbor', neighbor))
            
        if min_height is not None:
            
            _query_params.append(('min_height', min_height))
            
        if max_height is not None:
            
            _query_params.append(('max_height', max_height))
            
        if min_date is not None:
            
            _query_params.append(('min_date', min_date))
            
        if max_date is not None:
            
            _query_params.append(('max_date', max_date))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if token_currency is not None:
            
            _query_params.append(('token_currency', token_currency))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/entities/{entity}/links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_entity_neighbors(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        direction: Annotated[StrictStr, Field(description="Incoming or outgoing neighbors")],
        only_ids: Annotated[Optional[StrictStr], Field(description="Restrict result to given set of comma separated IDs")] = None,
        include_labels: Annotated[Optional[StrictBool], Field(description="Whether to include labels of first page of address tags")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        relations_only: Annotated[Optional[StrictBool], Field(description="Return only relations without entity details")] = None,
        exclude_best_address_tag: Annotated[Optional[StrictBool], Field(description="Whether to exclude best address tag")] = None,
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NeighborEntities:
        """(Deprecated) Get an entity's neighbors in the entity graph

        Get an entity's neighbors in the entity graph

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param direction: Incoming or outgoing neighbors (required)
        :type direction: str
        :param only_ids: Restrict result to given set of comma separated IDs
        :type only_ids: str
        :param include_labels: Whether to include labels of first page of address tags
        :type include_labels: bool
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param relations_only: Return only relations without entity details
        :type relations_only: bool
        :param exclude_best_address_tag: Whether to exclude best address tag
        :type exclude_best_address_tag: bool
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/neighbors is deprecated.", DeprecationWarning)

        _param = self._list_entity_neighbors_serialize(
            currency=currency,
            entity=entity,
            direction=direction,
            only_ids=only_ids,
            include_labels=include_labels,
            page=page,
            pagesize=pagesize,
            relations_only=relations_only,
            exclude_best_address_tag=exclude_best_address_tag,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NeighborEntities",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_entity_neighbors_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        direction: Annotated[StrictStr, Field(description="Incoming or outgoing neighbors")],
        only_ids: Annotated[Optional[StrictStr], Field(description="Restrict result to given set of comma separated IDs")] = None,
        include_labels: Annotated[Optional[StrictBool], Field(description="Whether to include labels of first page of address tags")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        relations_only: Annotated[Optional[StrictBool], Field(description="Return only relations without entity details")] = None,
        exclude_best_address_tag: Annotated[Optional[StrictBool], Field(description="Whether to exclude best address tag")] = None,
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NeighborEntities]:
        """(Deprecated) Get an entity's neighbors in the entity graph

        Get an entity's neighbors in the entity graph

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param direction: Incoming or outgoing neighbors (required)
        :type direction: str
        :param only_ids: Restrict result to given set of comma separated IDs
        :type only_ids: str
        :param include_labels: Whether to include labels of first page of address tags
        :type include_labels: bool
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param relations_only: Return only relations without entity details
        :type relations_only: bool
        :param exclude_best_address_tag: Whether to exclude best address tag
        :type exclude_best_address_tag: bool
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/neighbors is deprecated.", DeprecationWarning)

        _param = self._list_entity_neighbors_serialize(
            currency=currency,
            entity=entity,
            direction=direction,
            only_ids=only_ids,
            include_labels=include_labels,
            page=page,
            pagesize=pagesize,
            relations_only=relations_only,
            exclude_best_address_tag=exclude_best_address_tag,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NeighborEntities",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_entity_neighbors_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        direction: Annotated[StrictStr, Field(description="Incoming or outgoing neighbors")],
        only_ids: Annotated[Optional[StrictStr], Field(description="Restrict result to given set of comma separated IDs")] = None,
        include_labels: Annotated[Optional[StrictBool], Field(description="Whether to include labels of first page of address tags")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        relations_only: Annotated[Optional[StrictBool], Field(description="Return only relations without entity details")] = None,
        exclude_best_address_tag: Annotated[Optional[StrictBool], Field(description="Whether to exclude best address tag")] = None,
        include_actors: Annotated[Optional[StrictBool], Field(description="Whether to include actor information")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get an entity's neighbors in the entity graph

        Get an entity's neighbors in the entity graph

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param direction: Incoming or outgoing neighbors (required)
        :type direction: str
        :param only_ids: Restrict result to given set of comma separated IDs
        :type only_ids: str
        :param include_labels: Whether to include labels of first page of address tags
        :type include_labels: bool
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param relations_only: Return only relations without entity details
        :type relations_only: bool
        :param exclude_best_address_tag: Whether to exclude best address tag
        :type exclude_best_address_tag: bool
        :param include_actors: Whether to include actor information
        :type include_actors: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/neighbors is deprecated.", DeprecationWarning)

        _param = self._list_entity_neighbors_serialize(
            currency=currency,
            entity=entity,
            direction=direction,
            only_ids=only_ids,
            include_labels=include_labels,
            page=page,
            pagesize=pagesize,
            relations_only=relations_only,
            exclude_best_address_tag=exclude_best_address_tag,
            include_actors=include_actors,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NeighborEntities",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_entity_neighbors_serialize(
        self,
        currency,
        entity,
        direction,
        only_ids,
        include_labels,
        page,
        pagesize,
        relations_only,
        exclude_best_address_tag,
        include_actors,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if entity is not None:
            _path_params['entity'] = entity
        # process the query parameters
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        if only_ids is not None:
            
            _query_params.append(('only_ids', only_ids))
            
        if include_labels is not None:
            
            _query_params.append(('include_labels', include_labels))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        if relations_only is not None:
            
            _query_params.append(('relations_only', relations_only))
            
        if exclude_best_address_tag is not None:
            
            _query_params.append(('exclude_best_address_tag', exclude_best_address_tag))
            
        if include_actors is not None:
            
            _query_params.append(('include_actors', include_actors))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/entities/{entity}/neighbors',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def list_entity_txs(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        direction: Annotated[Optional[StrictStr], Field(description="Incoming or outgoing transactions")] = None,
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AddressTxs:
        """(Deprecated) Get all transactions an entity has been involved in

        Get all transactions an entity has been involved in

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param direction: Incoming or outgoing transactions
        :type direction: str
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/txs is deprecated.", DeprecationWarning)

        _param = self._list_entity_txs_serialize(
            currency=currency,
            entity=entity,
            direction=direction,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTxs",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def list_entity_txs_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        direction: Annotated[Optional[StrictStr], Field(description="Incoming or outgoing transactions")] = None,
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AddressTxs]:
        """(Deprecated) Get all transactions an entity has been involved in

        Get all transactions an entity has been involved in

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param direction: Incoming or outgoing transactions
        :type direction: str
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/txs is deprecated.", DeprecationWarning)

        _param = self._list_entity_txs_serialize(
            currency=currency,
            entity=entity,
            direction=direction,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTxs",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def list_entity_txs_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        direction: Annotated[Optional[StrictStr], Field(description="Incoming or outgoing transactions")] = None,
        min_height: Annotated[Optional[StrictInt], Field(description="Return transactions starting from given height")] = None,
        max_height: Annotated[Optional[StrictInt], Field(description="Return transactions up to (including) given height")] = None,
        min_date: Annotated[Optional[StrictStr], Field(description="Min date of txs")] = None,
        max_date: Annotated[Optional[StrictStr], Field(description="Max date of txs")] = None,
        order: Annotated[Optional[StrictStr], Field(description="Sorting order")] = None,
        token_currency: Annotated[Optional[StrictStr], Field(description="Return transactions of given token or base currency")] = None,
        page: Annotated[Optional[StrictStr], Field(description="Resumption token for retrieving the next page")] = None,
        pagesize: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Number of items returned in a single page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get all transactions an entity has been involved in

        Get all transactions an entity has been involved in

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param direction: Incoming or outgoing transactions
        :type direction: str
        :param min_height: Return transactions starting from given height
        :type min_height: int
        :param max_height: Return transactions up to (including) given height
        :type max_height: int
        :param min_date: Min date of txs
        :type min_date: str
        :param max_date: Max date of txs
        :type max_date: str
        :param order: Sorting order
        :type order: str
        :param token_currency: Return transactions of given token or base currency
        :type token_currency: str
        :param page: Resumption token for retrieving the next page
        :type page: str
        :param pagesize: Number of items returned in a single page
        :type pagesize: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /{currency}/entities/{entity}/txs is deprecated.", DeprecationWarning)

        _param = self._list_entity_txs_serialize(
            currency=currency,
            entity=entity,
            direction=direction,
            min_height=min_height,
            max_height=max_height,
            min_date=min_date,
            max_date=max_date,
            order=order,
            token_currency=token_currency,
            page=page,
            pagesize=pagesize,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AddressTxs",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_entity_txs_serialize(
        self,
        currency,
        entity,
        direction,
        min_height,
        max_height,
        min_date,
        max_date,
        order,
        token_currency,
        page,
        pagesize,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if entity is not None:
            _path_params['entity'] = entity
        # process the query parameters
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        if min_height is not None:
            
            _query_params.append(('min_height', min_height))
            
        if max_height is not None:
            
            _query_params.append(('max_height', max_height))
            
        if min_date is not None:
            
            _query_params.append(('min_date', min_date))
            
        if max_date is not None:
            
            _query_params.append(('max_date', max_date))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if token_currency is not None:
            
            _query_params.append(('token_currency', token_currency))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if pagesize is not None:
            
            _query_params.append(('pagesize', pagesize))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/entities/{entity}/txs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call_compat
    def search_entity_neighbors(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        direction: Annotated[StrictStr, Field(description="Incoming or outgoing neighbors")],
        key: Annotated[StrictStr, Field(description="Search key")],
        value: Annotated[StrictStr, Field(description="Comma separated search values")],
        depth: Annotated[StrictInt, Field(description="Search depth")],
        breadth: Annotated[StrictInt, Field(description="Search breadth")],
        skip_num_addresses: Annotated[Optional[StrictInt], Field(description="Skip entities with more than N addresses")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SearchResultLevel1]:
        """Search neighbors of an entity

        Search neighbors of an entity

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param direction: Incoming or outgoing neighbors (required)
        :type direction: str
        :param key: Search key (required)
        :type key: str
        :param value: Comma separated search values (required)
        :type value: str
        :param depth: Search depth (required)
        :type depth: int
        :param breadth: Search breadth (required)
        :type breadth: int
        :param skip_num_addresses: Skip entities with more than N addresses
        :type skip_num_addresses: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_entity_neighbors_serialize(
            currency=currency,
            entity=entity,
            direction=direction,
            key=key,
            value=value,
            depth=depth,
            breadth=breadth,
            skip_num_addresses=skip_num_addresses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SearchResultLevel1]",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call_compat
    def search_entity_neighbors_with_http_info(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        direction: Annotated[StrictStr, Field(description="Incoming or outgoing neighbors")],
        key: Annotated[StrictStr, Field(description="Search key")],
        value: Annotated[StrictStr, Field(description="Comma separated search values")],
        depth: Annotated[StrictInt, Field(description="Search depth")],
        breadth: Annotated[StrictInt, Field(description="Search breadth")],
        skip_num_addresses: Annotated[Optional[StrictInt], Field(description="Skip entities with more than N addresses")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SearchResultLevel1]]:
        """Search neighbors of an entity

        Search neighbors of an entity

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param direction: Incoming or outgoing neighbors (required)
        :type direction: str
        :param key: Search key (required)
        :type key: str
        :param value: Comma separated search values (required)
        :type value: str
        :param depth: Search depth (required)
        :type depth: int
        :param breadth: Search breadth (required)
        :type breadth: int
        :param skip_num_addresses: Skip entities with more than N addresses
        :type skip_num_addresses: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_entity_neighbors_serialize(
            currency=currency,
            entity=entity,
            direction=direction,
            key=key,
            value=value,
            depth=depth,
            breadth=breadth,
            skip_num_addresses=skip_num_addresses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SearchResultLevel1]",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call_compat
    def search_entity_neighbors_without_preload_content(
        self,
        currency: Annotated[StrictStr, Field(description="The cryptocurrency code (e.g., btc)")],
        entity: Annotated[StrictInt, Field(description="The entity ID")],
        direction: Annotated[StrictStr, Field(description="Incoming or outgoing neighbors")],
        key: Annotated[StrictStr, Field(description="Search key")],
        value: Annotated[StrictStr, Field(description="Comma separated search values")],
        depth: Annotated[StrictInt, Field(description="Search depth")],
        breadth: Annotated[StrictInt, Field(description="Search breadth")],
        skip_num_addresses: Annotated[Optional[StrictInt], Field(description="Skip entities with more than N addresses")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search neighbors of an entity

        Search neighbors of an entity

        :param currency: The cryptocurrency code (e.g., btc) (required)
        :type currency: str
        :param entity: The entity ID (required)
        :type entity: int
        :param direction: Incoming or outgoing neighbors (required)
        :type direction: str
        :param key: Search key (required)
        :type key: str
        :param value: Comma separated search values (required)
        :type value: str
        :param depth: Search depth (required)
        :type depth: int
        :param breadth: Search breadth (required)
        :type breadth: int
        :param skip_num_addresses: Skip entities with more than N addresses
        :type skip_num_addresses: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_entity_neighbors_serialize(
            currency=currency,
            entity=entity,
            direction=direction,
            key=key,
            value=value,
            depth=depth,
            breadth=breadth,
            skip_num_addresses=skip_num_addresses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SearchResultLevel1]",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_entity_neighbors_serialize(
        self,
        currency,
        entity,
        direction,
        key,
        value,
        depth,
        breadth,
        skip_num_addresses,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if currency is not None:
            _path_params['currency'] = currency
        if entity is not None:
            _path_params['entity'] = entity
        # process the query parameters
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if breadth is not None:
            
            _query_params.append(('breadth', breadth))
            
        if skip_num_addresses is not None:
            
            _query_params.append(('skip_num_addresses', skip_num_addresses))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{currency}/entities/{entity}/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


